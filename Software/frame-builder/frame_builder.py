#! /usr/bin/env python3
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 8.0
#  in conjunction with Tcl version 8.6
#    Jan 04, 2024 09:06:58 AM IST  platform: Linux
################################################################
# frame_builder.py
# Dev: Rr42@GitHub
# File version: v1.0
# Python version: 3.8.10 (Linux)
# Description:
#   Create and maintain a UI interface for building
#  custom frame sequences and exporting them in a
#  serializable format.
################################################################

import tkinter as tk
# from tkinter.constants import *

import frame_builder_UI as UI

from typing import Union, Literal, Final
from DBframe import HIGH, LOW, Logic, Pixel, Frame
import math

_debug: bool = True # False to eliminate debug printing from callback functions.

N_COLUMNS: Final[int] = 10
N_ROWS: Final[int] = 8
N_SUBPIXELS: Final[int] = 3
FRAME_WIDTH: Final[int] = N_ROWS*N_COLUMNS*N_SUBPIXELS

MESSAGE_TYPE = Literal["INFO", "ERROR", "WARNING"]

display_frames: str = ""
clear_all_flag: bool = False

def broadcast_message(msg: str, msg_type: MESSAGE_TYPE = "INFO") -> None:
    '''Function to broadcast a message to the user'''
    # Set the text color
    if msg_type == "INFO":
        _w1.Mmessages.configure(foreground="#000000")
    elif msg_type == "WARNING":
        _w1.Mmessages.configure(foreground="#ffff00")
    elif msg_type == "ERROR":
        _w1.Mmessages.configure(foreground="#ff0000")
    # Set the message text
    _w1.Mmessages.configure(text=msg)

def color_select_handle(color: str) -> None:
    '''Handler for the paint color selection'''
    # Clear message box
    broadcast_message(f"", "INFO")
    # Set the selected color label to reflect the selection
    _w1.Lselcolor.configure(background=color)
    # Set the text color to something readable
    if color in ["#000000", "#0000ff"]:
        _w1.Lselcolor.configure(foreground="#ffffff")
    else:
        _w1.Lselcolor.configure(foreground="#000000")

def painter_handle(c_index: int, r_index: int) -> None:
    '''Handler for the painting'''
    # Clear message box
    broadcast_message(f"", "INFO")
    # Set the selected color
    _w1.display_grid_labels[r_index][c_index].configure(background=_w1.Lselcolor["background"])
    _w1.display_grid_labels[r_index][c_index].configure(activebackground=_w1.Lselcolor["background"])

def rle(string: str) -> str:
    '''Function to compute the run-length encoded string'''
    rle_string: str = string
    return rle_string

def irle(rle_string: str) -> str:
    '''Function to compute the inverse run-length encoded string'''
    string: str = rle_string
    return string

def update_output() -> None:
    '''Function to refresh the output box using the global frame data'''
    global display_frames
    # Clear message box
    broadcast_message(f"", "INFO")
    # Run-length encode the string
    encoded_output: str = rle(display_frames)
    # Clear the output box
    _w1.Toutput.delete(1.0, tk.END)
    # Display the encoded output
    print(f"|{encoded_output}|")
    _w1.Toutput.insert(1.0, encoded_output)

def generate_handle() -> None:
    "Handler for generating the encoded output frame"
    global display_frames
    encoded_output: str = ""
    # Clear message box
    broadcast_message(f"", "INFO")
    # Get the existing data in the text box
    current_data: str = _w1.Toutput.get(1.0, tk.END).rstrip("\r\n")
    frame_count: int = len(current_data)//FRAME_WIDTH
    # Iterate through display grid and extract the display colors for the new frame
    for row_index in range(N_ROWS):
        for col_index in range(N_COLUMNS):
            bg_color: str = _w1.display_grid_labels[row_index][col_index]["background"]
            bg_color = bg_color.strip("#").replace("ff", "f").replace("00", "o")
            encoded_output += bg_color
    # Save the final frame data
    display_frames = current_data + encoded_output
    # Update the encoded output
    update_output()
    # Add an entry to the frame list
    _w1.LBselframe.insert(frame_count+1, f"Frame {frame_count+1}")

def update_handle() -> None:
    "Handler for updated the selected frame"
    global display_frames
    frame_data: str = ""
    # Clear message box
    broadcast_message(f"", "INFO")
    # Get the frame to be loaded
    if len(_w1.LBselframe.curselection()) == 0:
        broadcast_message(f"No frame selected to update!", "ERROR")
        return
    frame_index: int = _w1.LBselframe.curselection()[0]
    # Iterate through display grid and extract the display colors for the selected frame
    for col_index in range(N_COLUMNS):
        for row_index in range(N_ROWS):
            bg_color: str = _w1.display_grid_labels[row_index][col_index]["background"]
            bg_color = bg_color.strip("#").replace("ff", "f").replace("00", "o")
            frame_data += bg_color
    # Update the global frame data
    display_frames = display_frames[:FRAME_WIDTH*frame_index]+frame_data+display_frames[FRAME_WIDTH*(frame_index+1):]
    # Update the encoded output
    update_output()

def frame_select_handle(event) -> None:
    '''Handler for updating the display grid when a frame is selected'''
    global display_frames
    # Clear message box
    broadcast_message(f"", "INFO")
    # Get the frame to be loaded
    #  (event.widget == LBselframe)
    if len(_w1.LBselframe.curselection()) == 0:
        broadcast_message(f"No frame selected to display!", "ERROR")
        return
    frame_index: int = _w1.LBselframe.curselection()[0]
    # Extract the required frame
    frame_data: str = display_frames[FRAME_WIDTH*frame_index : FRAME_WIDTH*(frame_index+1)]
    # Iterate through display grid and apply the display colors
    for row_index in range(N_ROWS):
        for col_index in range(N_COLUMNS):
            pixel_offset: int = row_index*N_COLUMNS+col_index
            # Extract the pixel color
            pixel_color: str = frame_data[pixel_offset*N_SUBPIXELS:(pixel_offset+1)*N_SUBPIXELS]
            print(f"{pixel_offset} - {pixel_color}")
            pixel_color = "#"+pixel_color.replace("f", "ff").replace("o", "00")
            # Set the color on the display grid
            _w1.display_grid_labels[row_index][col_index].configure(background=pixel_color)

def load_handle() -> None:
    "Handler for loading the encoded frame"
    global display_frames, clear_all_flag
    # Clear message box
    broadcast_message(f"", "INFO")
    # Get the existing data in the text box
    current_encoded_data: str = _w1.Toutput.get(1.0, tk.END).rstrip("\r\n")
    # If the loaded data is empty clear everything
    if len(current_encoded_data) == 0:
        if clear_all_flag:
            # Clear the frame list
            _w1.LBselframe.delete(0, tk.END)
            # Clear frame data
            display_frames = ""
            update_output()
            # Reset the clear all flag
            clear_all_flag = False
        else:
            # Issue a warning for the first time
            broadcast_message(f"No data found for loading! Load again to clear existing data!", "WARNING")
        return
    # Decode the run-length encoded the string
    current_data: str = irle(current_encoded_data)
    frame_count: int = math.ceil(len(current_data)/FRAME_WIDTH)
    # Clear the frame list
    _w1.LBselframe.delete(0, tk.END)
    # Populate the frame list to reflect the loaded data
    for frame_index in range(1, frame_count+1):
        _w1.LBselframe.insert(frame_index, f"Frame {frame_index}")
    # Check if the data can be formed into frames
    padding: str = ""
    print(f"{frame_count=}")
    print(f"{(len(current_data)/FRAME_WIDTH)=}")
    if (len(current_data)/FRAME_WIDTH) != frame_count:
        broadcast_message(f"Insufficient amount of data for {math.ceil(len(current_data)/FRAME_WIDTH)} frames! Padding with 0s", "WARNING")
        # Pad the data to fit a frame
        padding = "o"*(frame_count*FRAME_WIDTH-len(current_data))
    else:
        broadcast_message(f"{frame_count} frames loaded", "INFO")
    # Save the final loaded frame data
    display_frames = current_data + padding
    # Update the encoded output
    update_output()

def main() -> None:
    '''Main entry point for the application.'''
    global root
    root = tk.Tk()
    root.protocol( 'WM_DELETE_WINDOW' , root.destroy)
    # Creates a toplevel widget.
    _top1: tk.Tk = root
    global _w1
    _w1 = UI.frame_builder_UI(_top1)
    root.mainloop()

if __name__ == "__main__":
    print("Launching UI...")
    UI.start_up()
    print("Waiting UI frontend to exit...")
    # Do cleanup stuff...
